export function count<A>(iter: Iterable<A>): number {
	let items = 0
	for (const _ of iter) items++
	return items
}
const swap = <T>(arr: T[], i: number, j: number) =>
	[arr[i], arr[j]] = [arr[j], arr[i]]
export function *permute<T>(arr: T[], stopIndex = arr.length, startIndex = 0): IterableIterator<T[]> {
	if (startIndex === stopIndex) {
		yield arr
		return
	}
	for (let swapIndex = startIndex; swapIndex < arr.length; swapIndex++) {
		swap(arr, startIndex, swapIndex)
		yield* permute(arr, stopIndex, startIndex + 1)
		swap(arr, startIndex, swapIndex)
	}
}
export const rand = (n: number): number => (Math.random() * n) | 0 //random number from 0 to n - 1
export const times = <A>(f: () => A, n: number): A[] => new Array<A>(n).fill(0 as any).map(f) //n items generated by f
export function transpose<A>(m: A[][]): A[][] { //assumes m is square
	const {length} = m
	const mT: A[][] = []
	for (let i = 0; i < length; i++) {
		const mTi = new Array<A>(length)
		for (let j = 0; j < length; j++) mTi[j] = m[j][i]
		mT[i] = mTi
	}
	return mT
}
export function* zip<A, B>(iter1: Iterable<A>, iter2: Iterable<B>): Iterable<[A, B]> {
	const iterator1 = iter1[Symbol.iterator](), iterator2 = iter2[Symbol.iterator]()
	let item1: IteratorResult<A>, item2: IteratorResult<B>
	while (!((item1 = iterator1.next()).done || (item2 = iterator2.next()).done)) yield [item1.value, item2.value]
}